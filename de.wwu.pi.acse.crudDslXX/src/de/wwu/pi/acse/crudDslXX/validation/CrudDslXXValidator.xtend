/*
 * generated by Xtext
 */
package de.wwu.pi.acse.crudDslXX.validation

import de.wwu.pi.acse.crudDslXX.crudDslXX.Button
import de.wwu.pi.acse.crudDslXX.crudDslXX.ButtonKind
import de.wwu.pi.acse.crudDslXX.crudDslXX.CrudDslXXPackage
import de.wwu.pi.acse.crudDslXX.crudDslXX.CrudModel
import de.wwu.pi.acse.crudDslXX.crudDslXX.EntityList
import de.wwu.pi.acse.crudDslXX.crudDslXX.EntryPage
import de.wwu.pi.acse.crudDslXX.crudDslXX.Field
import de.wwu.pi.acse.crudDslXX.crudDslXX.ListPage
import de.wwu.pi.acse.crudDslXX.crudDslXX.Page
import de.wwu.pi.acse.crudDslXX.crudDslXX.PageElement
import de.wwu.pi.acse.crudDslXX.crudDslXX.Reference
import org.eclipse.xtext.validation.Check

import static de.wwu.pi.acse.crudDslXX.crudDslXX.CrudDslXXPackage.Literals.*

import static extension de.wwu.pi.acse.crudDslXX.util.ModelUtil.*
import de.wwu.pi.acse.crudDslXX.crudDslXX.CompositeRef

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CrudDslXXValidator extends AbstractCrudDslXXValidator {

	public static val REFERENCE_OPPOSITES_MATCH_MESSAGE = 'The opposite reference does not have this reference as its opposite. '+ 
											'Opposite references must reference each other. It references %1$s instead of %2$s'

	@Check
	def checkReferenceOppositesMatch(Reference reference) {
		if (reference.opposite.opposite != reference)
			error(
				String::format(REFERENCE_OPPOSITES_MATCH_MESSAGE, reference.opposite.opposite.name, reference.name),
				REFERENCE__OPPOSITE
			)
	}

	@Check
	def checkModelNoDuplicatePagesForSameEntity(CrudModel model) {
		val duplicates = model.pages.filter(typeof(ListPage) ).getDuplicatesForSameEntity +
						 model.pages.filter(typeof(EntryPage)).getDuplicatesForSameEntity
		duplicates.forEach [ duplicate |
			error(
				"There is more than one page of this kind for the specified entity. " +
					"For each entity, there can be at most one EntryPage and one ListPage.", duplicate, PAGE__ENTITY)
		]
	}

	@Check
	def noPageForCompositeEntity(CrudModel model) {
		val compositeElem = model.entities.filter[composite]
		val wrongPages = model.pages.filter[curPage | compositeElem.exists[curPage.entity == it ]]
		wrongPages.forEach [ compositePage |
			error(
				"Pages for composite elements are not allowed.", compositePage, PAGE__ENTITY)
		]
	}

	@Check
	def compositeListDoesNotSpecifyAllRequiredAttributes(EntityList list) {
		if(list.reference instanceof CompositeRef) {
			val requiredProp = list.referingEntity.requiredProperties.toList
			val referencedProp = list.columnList.properties;

			requiredProp.removeAll(referencedProp)
			requiredProp.forEach[ prop |
				error(
				"Required property " + prop.name + " missing.", list, ENTITY_LIST__COLUMN_LIST)
			]
		}
	}

	def protected getDuplicatesForSameEntity(Iterable<? extends Page> pages) {
		pages.filter[page|pages.filter[it.entity == page.entity].size > 1]	//is there more than one Page
	}

	@Check
	def checkEntryPageAllPropertiesDisplayed(EntryPage page) {
		val propertiesDisplayed = page.getPropertiesDisplayed
		val allProperties = page.entity.properties
		allProperties.filter[!propertiesDisplayed.contains(it)].forEach [ propNotDisplayed |
			if (propNotDisplayed.optional)
				warning("No field displays optional property " + propNotDisplayed.name, PAGE__ENTITY)
			else
				error("No field displays required property " + propNotDisplayed.name, PAGE__ENTITY)
		]
	}

	def protected getPropertiesDisplayed(EntryPage page) {
		val propertiesDisplayed = newHashSet()
		val fieldsAndEntityLists = page.allFields + page.allUIElements.filter(typeof(EntityList))
		fieldsAndEntityLists.forEach [ curField |
			var prop = curField.getReferingProperty
			if (!propertiesDisplayed.add(prop))
				warning("Duplicate field for property " + prop.name, curField, FIELD__PROPERTY)
		]
		propertiesDisplayed
	}

	def getReferingProperty(PageElement elem) {
		switch (elem) {
			EntityList: elem.reference
			Field: elem.property
		}
	}

	@Check
	def checkReferenceMultiplicity(Reference reference) {
		if (reference.getMultiplicity() == reference.getOpposite().getMultiplicity())
				error("Only one-to-many relationships are supported. Change one multiplicity.",
					CrudDslXXPackage.Literals.REFERENCE__MULTIPLICITY);
	}
	
	@Check
	def checkEntryPageHasCreateButton(EntryPage page) {
		if (!page.allUIElements.filter(typeof(Button)).exists[kind == ButtonKind::CREATE_EDIT])
			error("No Create / Edit button is defined for this page.", PAGE__NAME);
	}
}
